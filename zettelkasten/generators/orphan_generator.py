"""Generate content for empty concept notes with complete Zettelkasten structure."""

import re
from pathlib import Path
from typing import List, Dict
from zettelkasten.core.config import Config
from zettelkasten.processors.concept_extractor import ConceptExtractor


class OrphanNoteGenerator:
    """Generate complete concept notes for empty files using Claude."""

    def __init__(self, config: Config):
        """
        Initialize OrphanNoteGenerator.

        Args:
            config: Application configuration
        """
        self.config = config
        self.concept_extractor = ConceptExtractor(config)

    def fill_empty_note(self, filepath: Path, backlink_sources: List[Dict] = None) -> str:
        """
        Generate a complete concept note for an empty file.

        Creates a full Zettelkasten note with:
        - Description/summary generated by Claude
        - Key Quotes section (empty template)
        - Related Notes section with backlinks pointing to this file

        Backlinks are discovered by finding other permanent notes that reference
        this concept in their Related Notes sections. Links point to the current
        file path to ensure correct bidirectional linking.

        For completely empty files, creates full frontmatter and structure.
        For files with existing structure, preserves it.

        Args:
            filepath: Path to the empty note file being filled
            backlink_sources: Optional list of dicts with 'title' and 'relative_path'
                            for each source note that references this concept

        Returns:
            Updated markdown content with full concept note structure
        """
        # Read the existing file
        content = filepath.read_text()

        # Extract the relative path for use in backlinks
        # Format: permanent-notes/20251024145426-concept-name
        relative_filepath = str(filepath.relative_to(filepath.parent.parent))

        # Check if file is completely empty
        if not content or not content.strip():
            # Extract title from filename
            filename = filepath.stem
            # Remove timestamp prefix (format: 20251024145426-title)
            parts = filename.split("-", 1)
            if len(parts) > 1:
                title = parts[1].replace("-", " ").title()
            else:
                title = filename

            # Generate complete note content
            note_content = self._generate_complete_note(title, backlink_sources, relative_filepath)

            # Create full note structure
            from datetime import datetime
            timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')

            lines = []
            lines.append("---")
            lines.append(f"title: {title}")
            lines.append(f"created: {timestamp}")
            lines.append("tags: [concept, permanent-note]")
            lines.append("---")
            lines.append("")
            lines.append(f"# {title}")
            lines.append("")
            lines.extend(note_content)
            lines.append("")

            return "\n".join(lines)

        # File has content - extract existing structure
        # Extract frontmatter
        frontmatter_match = re.match(r"^(---\s*\n.*?\n---\s*\n)", content, re.DOTALL)
        if frontmatter_match:
            frontmatter = frontmatter_match.group(1)
            after_frontmatter = content[frontmatter_match.end():]
        else:
            raise ValueError(f"Note {filepath} does not have valid frontmatter")

        # Extract title from frontmatter
        title_match = re.search(r"title:\s*(.+?)(?:\n|$)", frontmatter)
        if not title_match:
            raise ValueError(f"Could not extract title from {filepath}")

        title = title_match.group(1).strip().strip('"\'')

        # Extract title heading if present
        heading_match = re.search(r"^#\s+(.+?)$", after_frontmatter, re.MULTILINE)
        if heading_match:
            heading = heading_match.group(0)
        else:
            heading = f"# {title}"

        # Generate complete note content
        note_content = self._generate_complete_note(title, backlink_sources, relative_filepath)

        # Build the updated content
        lines = []
        lines.append(frontmatter.rstrip())
        lines.append("")
        lines.append(heading)
        lines.append("")
        lines.extend(note_content)
        lines.append("")

        return "\n".join(lines)

    def _generate_complete_note(self, concept_name: str, backlink_sources: List[Dict] = None, current_filepath: str = None) -> List[str]:
        """
        Generate a complete concept note with all sections.

        Creates a list of lines containing:
        - Description/summary
        - Key Quotes section (empty, for manual filling)
        - Related Notes section (with backlinks to this file if available)

        Args:
            concept_name: Name of the concept
            backlink_sources: List of dicts with 'title' and 'relative_path' for
                            notes that reference this concept
            current_filepath: Relative path to this file (e.g., permanent-notes/20251024145426-concept)

        Returns:
            List of markdown lines for the note content
        """
        # Generate description
        description = self._generate_summary(concept_name)

        lines = []

        # Add description
        lines.append(description)
        lines.append("")

        # Add Key Quotes section (empty template)
        lines.append("## Key Quotes")
        lines.append("")
        lines.append("")

        # Add Related Notes section with backlinks if available
        lines.append("## Related Notes")
        lines.append("")

        if backlink_sources:
            # Add backlinks to notes that reference this concept
            # Each backlink points to the source note file with the source note title as display name
            for backlink in backlink_sources:
                source_path = backlink["relative_path"]
                source_title = backlink["title"]
                lines.append(f"- [[{source_path}|{source_title}]]")
            lines.append("")

        lines.append("")

        return lines

    def _generate_summary(self, concept_name: str) -> str:
        """
        Generate a summary of a concept using Claude.

        Args:
            concept_name: Name of the concept to summarize

        Returns:
            Generated summary text
        """
        prompt = f"""Generate a clear, concise description of the concept "{concept_name}" suitable for a personal knowledge base.

The description should:
- Be 2-3 sentences
- Explain what the concept is and why it's important
- Be written in a way that helps build understanding
- Be actionable and practical where possible

Return only the description text, no JSON or formatting."""

        response = self.concept_extractor.client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=512,
            temperature=0.5,
            messages=[{"role": "user", "content": prompt}],
        )

        return response.content[0].text.strip()
