"""Generate note content with AI-powered summaries and intelligent linking."""

from typing import List, Dict, Optional
from zettelkasten.core.config import Config
from zettelkasten.processors.concept_extractor import ConceptExtractor


class NoteContentGenerator:
    """Generate content for notes with descriptions and related notes."""

    def __init__(self, config: Config):
        """
        Initialize NoteContentGenerator.

        Args:
            config: Application configuration
        """
        self.config = config
        self.concept_extractor = ConceptExtractor(config)

    def generate_concept_note_content(
        self,
        title: str,
        backlink_sources: List[Dict] = None,
        auto_fill: bool = False,
    ) -> List[str]:
        """
        Generate complete content for a concept note.

        Creates a list of lines containing:
        - Description/summary (generated by Claude if auto_fill=True)
        - Key Quotes section (empty template)
        - Related Notes section (with backlinks if available)

        Args:
            title: Title of the concept
            backlink_sources: List of dicts with 'title' and 'relative_path' for
                            notes that reference this concept
            auto_fill: If True, generate description from Claude

        Returns:
            List of markdown lines for the note content
        """
        lines = []

        # Add description
        if auto_fill:
            description = self._generate_summary(title)
            lines.append(description)
        else:
            lines.append("## Description")
            lines.append("")
            lines.append("<!-- Add your notes here -->")

        lines.append("")

        # Add Key Quotes section
        lines.append("## Key Quotes")
        lines.append("")
        lines.append("<!-- Add relevant quotes here -->")
        lines.append("")

        # Add Sources section
        lines.append("## Sources")
        lines.append("")
        lines.append("<!-- Link to source notes here -->")
        lines.append("")

        # Add Related Notes section
        lines.append("## Related Notes")
        lines.append("")

        if backlink_sources:
            # Add backlinks to notes that reference this concept
            for backlink in backlink_sources:
                source_path = backlink["relative_path"]
                source_title = backlink["title"]
                lines.append(f"- [[{source_path}|{source_title}]]")
            lines.append("")

        if not backlink_sources and auto_fill:
            # Even if no backlinks, add a blank line after header if auto-filled
            lines.append("")
        elif not backlink_sources:
            # Just the comment if not auto-filled
            lines.append("<!-- Link to related notes here -->")
            lines.append("")

        return lines

    def generate_source_note_content(self, auto_fill: bool = False) -> List[str]:
        """
        Generate content for a source/literature note.

        Args:
            auto_fill: If True, include placeholder for content

        Returns:
            List of markdown lines for the note content
        """
        lines = []

        lines.append("## Summary")
        lines.append("")
        lines.append("<!-- Add summary of the source here -->")
        lines.append("")

        lines.append("## Key Points")
        lines.append("")
        lines.append("<!-- Add key takeaways here -->")
        lines.append("")

        lines.append("## Related Concepts")
        lines.append("")
        lines.append("<!-- Link to related concept notes here -->")
        lines.append("")

        return lines

    def generate_fleeting_note_content(self) -> List[str]:
        """
        Generate content for a fleeting/temporary note.

        Returns:
            List of markdown lines for the note content
        """
        lines = []

        lines.append("<!-- This is a fleeting note - temporary thoughts or ideas -->")
        lines.append("")

        return lines

    def generate_person_note_content(
        self,
        title: str,
        auto_fill: bool = False,
        research_data: Optional[Dict] = None,
    ) -> List[str]:
        """
        Generate content for a person/contact note.

        Creates a structured note with professional information:
        - Professional summary
        - Background
        - Expertise areas
        - Digital presence (website, LinkedIn, social media)
        - Programs/ventures
        - Key Quotes section
        - Related Notes

        Args:
            title: Name of the person
            auto_fill: If True, include research data
            research_data: Pre-populated research data dictionary

        Returns:
            List of markdown lines for the note content
        """
        lines = []

        # Add summary if available from research
        if auto_fill and research_data and research_data.get('summary'):
            lines.append(research_data['summary'])
            lines.append('')
        else:
            lines.append('## Professional Summary')
            lines.append('')
            lines.append('<!-- Add professional summary here -->')
            lines.append('')

        # Add background section if available
        if auto_fill and research_data and research_data.get('background'):
            lines.append('## Background')
            lines.append('')
            lines.append(research_data['background'])
            lines.append('')

        # Add expertise section if available
        if auto_fill and research_data and research_data.get('expertise'):
            lines.append('## Expertise')
            lines.append('')
            lines.append(research_data['expertise'])
            lines.append('')

        # Add digital presence section if available
        if auto_fill and research_data and research_data.get('digital_presence'):
            lines.append('## Digital Presence')
            lines.append('')
            for platform, handle_or_url in research_data['digital_presence'].items():
                if handle_or_url.startswith('http'):
                    lines.append(f"- **{platform}**: {handle_or_url}")
                else:
                    lines.append(f"- **{platform}**: {handle_or_url}")
            lines.append('')

        # Add programs/ventures section if available
        if auto_fill and research_data and research_data.get('programs_ventures'):
            lines.append('## Programs & Ventures')
            lines.append('')
            for program in research_data['programs_ventures']:
                lines.append(f"- {program}")
            lines.append('')

        # Add Key Quotes section
        lines.append('## Key Quotes')
        lines.append('')
        lines.append('<!-- Add relevant quotes here -->')
        lines.append('')

        # Add Sources section
        lines.append('## Sources')
        lines.append('')
        lines.append('<!-- Link to source notes here -->')
        lines.append('')

        # Add Related Notes section
        lines.append('## Related Notes')
        lines.append('')
        lines.append('<!-- Link to related notes here -->')
        lines.append('')

        return lines

    def _generate_summary(self, concept_name: str) -> str:
        """
        Generate a summary of a concept using Claude.

        Args:
            concept_name: Name of the concept to summarize

        Returns:
            Generated summary text
        """
        prompt = f"""Generate a clear, concise description of the concept "{concept_name}" suitable for a personal knowledge base.

The description should:
- Be 2-3 sentences
- Explain what the concept is and why it's important
- Be written in a way that helps build understanding
- Be actionable and practical where possible

Return only the description text, no JSON or formatting."""

        response = self.concept_extractor.client.messages.create(
            model="claude-3-haiku-20240307",
            max_tokens=512,
            temperature=0.5,
            messages=[{"role": "user", "content": prompt}],
        )

        return response.content[0].text.strip()
